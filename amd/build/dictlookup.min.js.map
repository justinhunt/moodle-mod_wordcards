{"version":3,"file":"dictlookup.min.js","sources":["../src/dictlookup.js"],"sourcesContent":["/**\n * dictionary lookup\n *\n * @package mod_wordcards\n * @author  Justin Hunt - poodll.com\n * *\n */\n\ndefine(['jquery','core/log'], function($,log) {\n\n    \"use strict\"; // jshint ;_;\n\n    log.debug('Wordcards dictionary lookup: initialising');\n\n    return {\n        init: function (cmid) {\n            log.debug('Wordcards dictionary lookup: initialising');\n            this.cmid = cmid;\n            this.modid = modid;\n        },\n\n        english_lone: async function (allwords, langdef) {\n            var that = this;\n            var langs = ['ar', 'id', 'zh', 'zh_tw', 'ja', 'ko', 'pt', 'es', 'th', 'vi', 'fr', 'rus'];\n\n            //if we have no words, do nothing\n            if (allwords.trim() === '') {\n                return false;\n            }\n            //if the definitions language is not a language supported by the ESL Apps dictionary, re-route to MS API\n            if (langs.indexOf(langdef) === -1) {\n                return alllangs_lone(allwords, 'en', langdef);\n            }\n\n            var promises = await ajax.call([\n                {\n                    methodname: 'mod_wordcards_search_dictionary',\n                    args: {terms: allwords, cmid: that.cmid, sourcelang: 'en', targetlangs: langdef}\n                },\n            ]);\n\n           var final_results = await promises[0].done(async function (response) {\n                //if return code=0, disaster, log and die\n                if (response.success === 0) {\n                    log.debug(response.payload);\n                    return false;\n                }\n                var repeatsearch_terms = [];\n                var terms = JSON.parse(response.payload);\n                var allterms_result = [];\n                for (var i = 0; i < terms.length; i++) {\n                    var theterm = terms[i];\n                    //if a word search failed, try MS API for it\n                    if (theterm.count === 0) {\n                        repeatsearch_terms.push(theterm.term);\n                    } else {\n                        var tdata = {term: theterm.term, senses: [], modid: that.modid};\n                        for (var sindex in theterm.results) {\n                            var sense = theterm.results[sindex];\n                            //by default its term:English def:English\n                            var sourcedefinition = sense.definition;\n                            var alltrans = {};\n                            for (var ti = 0; ti < langs.length; ti++) {\n                                alltrans[langs[ti]] = sense['lang_' + langs[ti]];\n                            }\n                            var translations = JSON.stringify(alltrans);\n                            var definition = sourcedefinition;\n                            //if its NOT term:english and def:english, we pull the definition from the translation\n                            if (langdef !== \"en\") {\n                                if (sense.hasOwnProperty('lang_' + langdef)) {\n                                    definition = sense['lang_' + langdef];\n                                } else if (langdef === 'en') {\n                                    definition = sense.meaning;\n                                } else {\n                                    definition = 'No translation available';\n                                }\n                            }\n\n                            //model sentence is only in english (for now)\n                            var modelsentence = sense.example;\n\n\n                            tdata.senses.push({\n                                definition: definition, sourcedefinition: sourcedefinition,\n                                modelsentence: modelsentence, senseindex: sindex, translations: translations\n                            });\n                        }//end of results loop\n                        allterms_result.push(tdata);\n                    }\n                }\n                //if we have any words that failed on ESL Apps dictionary, we try MS API for them\n                if(repeatsearch_terms.length>0){\n                  var repeatsearch_results= await alllangs_lone(repeatsearch_terms.join(','), 'en', langdef);\n                  if (repeatsearch_results) {\n                      allterms_result = allterms_result.concat(repeatsearch_results);\n                  }\n                }\n                //we return the combined results of search and repeatsearch\n                return allterms_result;\n            });\n           //we return results to mustache\n            return final_results;\n        },\n\n        alllangs_lone: async function (allwords, sourcelang, targetlang) {\n            var that = this;\n            var langs = {\n                \"af\": \"Afrikaans\",\n                \"ar\": \"Arabic\",\n                \"bn\": \"Bangla\",\n                \"bs\": \"Bosnian\",\n                \"bg\": \"Bulgarian\",\n                \"ca\": \"Catalan\",\n                \"cs\": \"Czech\",\n                \"cy\": \"Welsh\",\n                \"da\": \"Danish\",\n                \"de\": \"German\",\n                \"el\": \"Greek\",\n                \"en\": \"English\",\n                \"es\": \"Spanish\",\n                \"et\": \"Estonian\",\n                \"fa\": \"Persian\",\n                \"fi\": \"Finnish\",\n                \"fr\": \"French\",\n                \"ht\": \"Haitian Creole\",\n                \"he\": \"Hebrew\",\n                \"hi\": \"Hindi\",\n                'hr': 'Croatian',\n                'hu': 'Hungarian',\n                'id': 'Indonesian',\n                'is': 'Icelandic',\n                'it': 'Italian',\n                'ja': 'Japanese',\n                'ko': 'Korean',\n                'lt': 'Lithuanian',\n                'lv': 'Latvian',\n                'mww': 'Hmong Daw',\n                'ms': 'Malay',\n                'mt': 'Maltese',\n                'nl': 'Dutch',\n                'nb': 'Norwegian',\n                'pl': 'Polish',\n                'pt': 'Portuguese',\n                'ro': 'Romanian',\n                'ru': 'Russian',\n                'sr-Latn': 'Serbian (Latin)',\n                'sk': 'Slovak',\n                'sl': 'Slovenian',\n                'sv': 'Swedish',\n                'ta': 'Tamil',\n                'th': 'Thai',\n                'tr': 'Turkish',\n                'uk': 'Ukrainian',\n                'ur': 'Urdu',\n                'vi': 'Vietnamese',\n                'zh-Hans': 'Chinese Simplified'\n            }\n           \n\n            //if we have no words, do nothing\n            if (allwords.trim() === '') {\n                log.debug('no words submitted to search for');\n                return [];\n            }\n\n            //if the definitions language is not a language supported by the MS dictionary we give up\n            if (langs.indexOf(sourcelang) === -1 || langs.indexOf(targetlang) === -1) {\n                log.debug('MS API does not support ' + sourcelang + ' or ' + targetlang);\n                return [];\n            }\n\n            var promises = await ajax.call([\n                {\n                    methodname: 'mod_wordcards_search_dictionary',\n                    args: {terms: allwords, cmid: that.cmid, sourcelang: 'en', targetlangs: langdef}\n                },\n            ]);\n\n            var final_results = await promises[0].done(async function (response) {\n                //if return code=0, disaster, log and die\n                if (response.success === 0) {\n                    log.debug(response.payload);\n                    return [];\n                }\n\n                //fetch the words from the API and turn them into data that the mustache template can use\n                var terms = JSON.parse(response.payload);\n                var allterms_result = [];\n                for (var i = 0; i < terms.length; i++) {\n                    var theterm = terms[i];\n                    //if a word search failed, and an empty blank result\n                    if (theterm.count === 0) {\n                        var senses=[];\n                        senses.push({definition: '',sourcedefinition: 'No def. available',\n                            modelsentence: '', senseindex: 0, translations: '{}'})\n                        var tdata = {term: theterm.term, senses: senses, modid:that.modid};\n                        allterms_result.push(tdata);\n\n                    } else {\n                        var tdata = {term: theterm.term, senses: [], modid: that.modid};\n                        for (var sindex in theterm.results) {\n                            var sense = theterm.results[sindex];\n                            //definition = the translation, ie L2 definitions\n                            //source definition = the L1 definition. we might not know that, and prob wont use it\n                            var definition = sense.definition;\n                            var alltrans = {};\n                            alltrans[targetlang] = definition;\n\n                            var translations = JSON.stringify(alltrans);\n                            //how could it be empty?\n                            if (definition === \"\") {\n                                definition = 'No translation available';\n                            }\n\n                            //model sentence is only in english (for now)\n                            var modelsentence = sense.example;\n\n\n                            tdata.senses.push({\n                                definition: definition, sourcedefinition: definition,\n                                modelsentence: modelsentence, senseindex: sindex, translations: translations\n                            });\n                        }//end of results loop\n                        allterms_result.push(tdata);\n                    }\n                }\n\n                //we return the combined results of search and repeatsearch\n                return allterms_result;\n\n            });\n            //we return results to mustache\n            return final_results;\n\n\n        }\n    }\n\n});\n\n"],"names":["define","$","log","debug","init","cmid","modid","english_lone","allwords","langdef","that","this","langs","trim","indexOf","alllangs_lone","ajax","call","methodname","args","terms","sourcelang","targetlangs","promises","done","response","success","payload","repeatsearch_terms","JSON","parse","allterms_result","i","length","theterm","count","push","term","sindex","tdata","senses","results","sense","sourcedefinition","definition","alltrans","ti","translations","stringify","hasOwnProperty","meaning","modelsentence","example","senseindex","join","repeatsearch_results","concat","final_results","targetlang"],"mappings":"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"}