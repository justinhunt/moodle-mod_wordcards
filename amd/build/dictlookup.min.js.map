{"version":3,"file":"dictlookup.min.js","sources":["../src/dictlookup.js"],"sourcesContent":["/**\n * dictionary lookup\n *\n * @package mod_wordcards\n * @author  Justin Hunt - poodll.com\n * *\n */\n\ndefine(['jquery','core/log','core/ajax','core/templates'], function($,log,ajax,templates) {\n\n    \"use strict\"; // jshint ;_;\n\n    log.debug('Wordcards dictionary lookup: initialising');\n\n    return {\n        init: function (cmid,modid,resultscont) {\n            log.debug('Wordcards dictionary lookup: initialising');\n            this.cmid = cmid;\n            this.modid = modid;\n            this.resultscont = resultscont;\n        },\n\n        update_page: function(alldata){\n\n            //update the page\n            var that = this;\n            that.resultscont.empty();\n\n            for(var i = 0; i < alldata.length; i++)\n            {\n                var tdata = alldata[i];\n                templates.render('mod_wordcards/word_wizard_oneresult', tdata).then(\n                    function (html, js) {\n                        that.resultscont.append(html);\n                        templates.runTemplateJS(js);\n                    }\n                );\n            }\n        },\n\n        add_result_to_page: function(termdata) {\n            var that = this;\n            templates.render('mod_wordcards/word_wizard_oneresult', termdata).then(\n                function (html, js) {\n                    that.resultscont.prepend(html);\n                    templates.runTemplateJS(js);\n                }\n            );\n        },\n\n        getwords: function (allwords,sourcelang,definitionslang) {\n            var that = this;\n\n            //if we have no words, do nothing\n            if (allwords.trim() === '') {\n                return false;\n            }\n\n            that.resultscont.empty();\n\n        //originally we passed a single request with all words in a CSV list in the terms arg\n        //but that was too slow because the server would process them sequentially\n        // so now we make a request for each word. It would still work with a single request\n            var requests = [];\n            var wordarray = allwords.split(',');\n            for (var i = 0; i < wordarray.length; i++) {\n                var word = wordarray[i].trim();\n                if (word !== '') {\n                    requests.push({\n                        methodname: 'mod_wordcards_search_dictionary',\n                        args: {terms: word, cmid: that.cmid, sourcelang: sourcelang, targetlangs: definitionslang},\n                        async: true\n                    });\n                    //add placeholders for each word\n                    var tdata = {'term': word, 'termno': i};\n                    templates.render('mod_wordcards/ww_skeleton',tdata).done(function(html, js) {\n                        that.resultscont.append(html);\n                    }).fail(function(ex) {\n                        log.error(ex);\n                    });\n                }\n            }\n        \n           // Loop through the requests, send and respond to each \n           for (let reqindex=0; reqindex < requests.length; reqindex++){\n                ajax.call([requests[reqindex]],true)[0].then(response=>{\n                    //remove the skeleton placeholder\n                    $('#mod_wordcards_wwskeleton_'+ reqindex).remove();\n\n                    //if return code=0, disaster, log and continue\n                    if (response.success === 0) {\n                        log.debug(response.payload);\n                    }\n                    var terms = JSON.parse(response.payload);\n                    for (var i = 0; i < terms.length; i++) {\n                        var theterm = terms[i];\n                        //if a word search failed\n                        if (theterm.count === 0) {\n                            var senses = [];\n                            senses.push({\n                                definition: '', sourcedefinition: 'No def. available',\n                                modelsentence: '', senseindex: 0, translations: '{}'\n                            })\n                            var tdata = {term: theterm.term, senses: senses, modid: that.modid};\n                            allterms_result.push(tdata);\n\n                        } else {\n                            var tdata = {term: theterm.term, senses: [], modid: that.modid};\n                            for (var sindex in theterm.results) {\n                                var sense = theterm.results[sindex];\n                                //by default its term:English def:English\n                                var sourcedefinition = sense.definition;\n                                var alltrans = {};\n                                for (var langkey in sense) {\n                                    if (sense.hasOwnProperty(langkey) && langkey.startsWith('lang_')) {\n                                        alltrans[langkey.substring(5)] = sense[langkey];\n                                    }\n                                }\n\n                                var translations = JSON.stringify(alltrans);\n                                var definition = sourcedefinition;\n                                //if its NOT term:english and def:english, we pull the definition from the translation\n                                if (definitionslang !== \"en\") {\n                                    if (sense.hasOwnProperty('lang_' + definitionslang)) {\n                                        definition = sense['lang_' + definitionslang];\n                                    } else if (definitionslang === 'en') {\n                                        definition = sense.meaning;\n                                    } else {\n                                        definition = 'No translation available';\n                                    }\n                                }\n\n                                //model sentence)\n                                var modelsentence = sense.example;\n\n\n                                tdata.senses.push({\n                                    definition: definition, sourcedefinition: sourcedefinition,\n                                    modelsentence: modelsentence, senseindex: sindex, translations: translations\n                                });\n                            }//end of results loop\n                            \n                            that.add_result_to_page(tdata);\n                        }\n                    }//end of terms loop\n                });\n           }\n           \n           return;\n\n                  \n           var wordpromises = [];\n           for (var reqindex=0; reqindex < requests.length; reqindex++){\n                wordpromises.push(ajax.call([requests[reqindex]],true)[0]); \n           }\n\n      \n          // This, oddly, did not run the requests in parallel.\n          // So it was too slow and errored on occasion (timeouts I think).\n          //var wordpromises = ajax.call(requests,true);\n         \n            \n            Promise.all(wordpromises).then(function(allresponses){\n                var allterms_result = [];\n                if(allresponses.length===0){\n                    return allterms_result;\n                }\n\n                for(var responseindex = 0; responseindex < allresponses.length; responseindex++) {\n\n                    var response = allresponses[responseindex];\n\n                    //if return code=0, disaster, log and continue\n                    if (response.success === 0) {\n                        log.debug(response.payload);\n                    }\n                    var terms = JSON.parse(response.payload);\n                    for (var i = 0; i < terms.length; i++) {\n                        var theterm = terms[i];\n                        //if a word search failed\n                        if (theterm.count === 0) {\n                            var senses = [];\n                            senses.push({\n                                definition: '', sourcedefinition: 'No def. available',\n                                modelsentence: '', senseindex: 0, translations: '{}'\n                            })\n                            var tdata = {term: theterm.term, senses: senses, modid: that.modid};\n                            allterms_result.push(tdata);\n\n                        } else {\n                            var tdata = {term: theterm.term, senses: [], modid: that.modid};\n                            for (var sindex in theterm.results) {\n                                var sense = theterm.results[sindex];\n                                //by default its term:English def:English\n                                var sourcedefinition = sense.definition;\n                                var alltrans = {};\n                                for (var langkey in sense) {\n                                    if (sense.hasOwnProperty(langkey) && langkey.startsWith('lang_')) {\n                                        alltrans[langkey.substring(5)] = sense[langkey];\n                                    }\n                                }\n\n                                var translations = JSON.stringify(alltrans);\n                                var definition = sourcedefinition;\n                                //if its NOT term:english and def:english, we pull the definition from the translation\n                                if (definitionslang !== \"en\") {\n                                    if (sense.hasOwnProperty('lang_' + definitionslang)) {\n                                        definition = sense['lang_' + definitionslang];\n                                    } else if (definitionslang === 'en') {\n                                        definition = sense.meaning;\n                                    } else {\n                                        definition = 'No translation available';\n                                    }\n                                }\n\n                                //model sentence)\n                                var modelsentence = sense.example;\n\n\n                                tdata.senses.push({\n                                    definition: definition, sourcedefinition: sourcedefinition,\n                                    modelsentence: modelsentence, senseindex: sindex, translations: translations\n                                });\n                            }//end of results loop\n                            allterms_result.push(tdata);\n                        }\n                    }//end of terms loop\n                }//end of allresponses loop\n                that.update_page(allterms_result );\n            });//end of promise then\n    \n        },\n    }\n\n});\n\n"],"names":["define","$","log","ajax","templates","debug","init","cmid","modid","resultscont","update_page","alldata","that","this","empty","i","length","tdata","render","then","html","js","append","runTemplateJS","add_result_to_page","termdata","prepend","getwords","allwords","sourcelang","definitionslang","trim","requests","wordarray","split","word","push","methodname","args","terms","targetlangs","async","done","fail","ex","error","reqindex","call","response","remove","success","payload","JSON","parse","theterm","count","senses","definition","sourcedefinition","modelsentence","senseindex","translations","term","allterms_result","sindex","results","sense","alltrans","langkey","hasOwnProperty","startsWith","substring","stringify","meaning","example"],"mappings":"AAQAA,kCAAO,CAAC,SAAS,WAAW,YAAY,mBAAmB,SAASC,EAAEC,IAAIC,KAAKC,kBAI3EF,IAAIG,MAAM,6CAEH,CACHC,KAAM,SAAUC,KAAKC,MAAMC,aACvBP,IAAIG,MAAM,kDACLE,KAAOA,UACPC,MAAQA,WACRC,YAAcA,aAGvBC,YAAa,SAASC,aAGdC,KAAOC,KACXD,KAAKH,YAAYK,YAEb,IAAIC,EAAI,EAAGA,EAAIJ,QAAQK,OAAQD,IACnC,KACQE,MAAQN,QAAQI,GACpBX,UAAUc,OAAO,sCAAuCD,OAAOE,MAC3D,SAAUC,KAAMC,IACZT,KAAKH,YAAYa,OAAOF,MACxBhB,UAAUmB,cAAcF,SAMxCG,mBAAoB,SAASC,cACrBb,KAAOC,KACXT,UAAUc,OAAO,sCAAuCO,UAAUN,MAC9D,SAAUC,KAAMC,IACZT,KAAKH,YAAYiB,QAAQN,MACzBhB,UAAUmB,cAAcF,QAKpCM,SAAU,SAAUC,SAASC,WAAWC,qBAChClB,KAAOC,QAGa,KAApBe,SAASG,cACF,EAGXnB,KAAKH,YAAYK,gBAKbkB,SAAW,GACXC,UAAYL,SAASM,MAAM,KACtBnB,EAAI,EAAGA,EAAIkB,UAAUjB,OAAQD,IAAK,KACnCoB,KAAOF,UAAUlB,GAAGgB,UACX,KAATI,KAAa,CACbH,SAASI,KAAK,CACVC,WAAY,kCACZC,KAAM,CAACC,MAAOJ,KAAM5B,KAAMK,KAAKL,KAAMsB,WAAYA,WAAYW,YAAaV,iBAC1EW,OAAO,QAGPxB,MAAQ,MAASkB,YAAgBpB,GACrCX,UAAUc,OAAO,4BAA4BD,OAAOyB,MAAK,SAAStB,KAAMC,IACpET,KAAKH,YAAYa,OAAOF,SACzBuB,MAAK,SAASC,IACb1C,IAAI2C,MAAMD,YAMlB,IAAIE,SAAS,EAAGA,SAAWd,SAAShB,OAAQ8B,WAC5C3C,KAAK4C,KAAK,CAACf,SAASc,YAAW,GAAM,GAAG3B,MAAK6B,WAEzC/C,EAAE,6BAA8B6C,UAAUG,SAGjB,IAArBD,SAASE,SACThD,IAAIG,MAAM2C,SAASG,iBAEnBZ,MAAQa,KAAKC,MAAML,SAASG,SACvBpC,EAAI,EAAGA,EAAIwB,MAAMvB,OAAQD,IAAK,KAC/BuC,QAAUf,MAAMxB,MAEE,IAAlBuC,QAAQC,MAAa,KACjBC,OAAS,GACbA,OAAOpB,KAAK,CACRqB,WAAY,GAAIC,iBAAkB,oBAClCC,cAAe,GAAIC,WAAY,EAAGC,aAAc,WAEhD5C,MAAQ,CAAC6C,KAAMR,QAAQQ,KAAMN,OAAQA,OAAQhD,MAAOI,KAAKJ,OAC7DuD,gBAAgB3B,KAAKnB,WAElB,CACCA,MAAQ,CAAC6C,KAAMR,QAAQQ,KAAMN,OAAQ,GAAIhD,MAAOI,KAAKJ,WACpD,IAAIwD,UAAUV,QAAQW,QAAS,KAC5BC,MAAQZ,QAAQW,QAAQD,QAExBN,iBAAmBQ,MAAMT,WACzBU,SAAW,OACV,IAAIC,WAAWF,MACZA,MAAMG,eAAeD,UAAYA,QAAQE,WAAW,WACpDH,SAASC,QAAQG,UAAU,IAAML,MAAME,cAI3CP,aAAeT,KAAKoB,UAAUL,UAC9BV,WAAaC,iBAEO,OAApB5B,kBAEI2B,WADAS,MAAMG,eAAe,QAAUvC,iBAClBoC,MAAM,QAAUpC,iBACF,OAApBA,gBACMoC,MAAMO,QAEN,gCAKjBd,cAAgBO,MAAMQ,QAG1BzD,MAAMuC,OAAOpB,KAAK,CACdqB,WAAYA,WAAYC,iBAAkBA,iBAC1CC,cAAeA,cAAeC,WAAYI,OAAQH,aAAcA,eAIxEjD,KAAKY,mBAAmBP"}